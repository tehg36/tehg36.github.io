---
layout: single
title:  "이론 공부 - 프로세스(Process) & 스레드(Thread) & 태스크(Task) & 코루틴(Coroutine)"
categories: Theory Study
tag: [Study, Theory, Process, Thread, Task, Coroutine]
toc: true
---

> ## 프로세스 (Process)

프로세스는 실행 중인 프로그램으로, 운영체제에 의해 관리되는 독립적인 메모리 공간을 가지고 있다. 각 프로세스는 자신만의 주소 공간, 데이터, 스택, 힙 등을 가지고 있으며, 운영체제에서는 각각의 프로세스에게 별도의 리소스(메모리, CPU 시간 등)를 할당합니다. 각 프로세스는 독립적으로 실행되며, 다른 프로세스의 영향을 받지 않는다.

* 장점:
  * 각각의 프로세스는 독립적으로 실행되기 때문에 안정성이 높다.
  * 각 프로세스는 독립적인 메모리 공간을 가지기 때문에 다른 프로세스의 데이터에 접근하는 일이 없다.
* 단점:
  * 각각의 프로세스는 운영체제에게 별도의 리소스를 할당받기 때문에, 메모리와 CPU 자원을 많이 소모한다.
  * 프로세스 간 통신이 필요한 경우 별도의 메커니즘이 필요하며, 이는 복잡한 구조를 가질 수 있다.


> ## 스레드 (Thread)

스레드는 프로세스 안에서 실행되는 실행 단위이다. 각 프로세스는 하나 이상의 스레드를 가지고 있으며, 각 스레드는 프로세스의 메모리 공간을 공유한다. 이는 각 스레드가 프로세스 안에서 동시에 실행될 수 있음을 의미한다.

* 장점:
  * 스레드는 프로세스 내부에서 실행되기 때문에, 프로세스 간 통신보다 더 빠르게 데이터를 공유할 수 있습니다.
  * 여러 스레드를 사용하는 경우, 프로세스보다 더 적은 자원(메모리 등)을 사용할 수 있습니다.
* 단점:
  * 각 스레드는 프로세스 내부에서 실행되기 때문에, 하나의 스레드가 예외를 발생시키면 전체 프로세스가 영향을 받을 수 있습니다.
  * 공유 자원에 대한 동기화 문제가 발생할 수 있습니다.

> ## 태스크 (Task)

테스크는 비동기적으로 실행되는 코드 블록을 만한다. 각각의 태스크는 독립적인 실행 흐름을 가지며, 운영체제에서 관리되는 것이 아닌, 프로그램에서 직접 관리한다. 이러한 비동기성은 블로킹되지 않고 다른 작업과 병렬적으로 처리할 수 있다. 태스크는 비동기 프로그래밍에서 자주 사용되며, 일반적으로는 콜백 함수보다 직관적이고 유연한 코드를 작성 할 수 있다.

* 장점:
  * 블로킹되지 않고 비동기적으로 실행되므로, 다른 작업과 병렬적으로 처리할 수 있다.
  * 콜백 함수보다 직관적이고 유연한 코드 작성 가능하다.
* 단점:
  * 직접 관리해야 하므로 코드가 복잡해질 수 있다.
  * 비동기성 떄문에 동기 코드와 같은 방식으로 디버깅 어려울 수 있다.

> ## 코루틴 (Coroutine)

코루틴은 여러개의 진입점(Entry Point)을 가진 함수로, 함수 실행 중에 일시 중단되고 나중에 다시 시작될 수 있다. 이를 통해 코루틴은 마치 스레드처럼 동작할 수 있으며, 비동기 코드를 작성하기 위한 다른 방법으로 자주 사용된다.

* 장점:
  * 동시성 작업에서 일시 중단하고 재개할 수 있으므로, 자원사용이 효율적이다
  * 코루틴은 일반적으로 스레드보다 적은 메모리를 사용하고, 디버깅이 쉽다.
* 단점:
  * 코루틴은 동시성 작업에서 사용할 수 있으며, 동기 코드와 같은 방식으로 디버깅하기 어려울 수 있다.

> ## 서로의 차이점

### 프로세스 (Process) 와 스레드 (Thread)

프로세스와 스레드는 모두 실행 단위이지만 차이점이있다.

1. 리소스할당
   * 프로세스는 운영체제에 의해 별도의 메모리 공간과 CPU 자원 등이 할당된다. 각 프로세스는 독립적인 메모리 공간을 가지기 때문에 다른 프로세스의 데이터에 접근하는 일이 없다. 스레드는 프로세스 내부에서 실행되기 때문에, 프로세스가 가지고 있는 메모리 공간 등의 자원을 공유한다.
2. 동작 방식
   * 각 프로세스는 독립적으로 실행되기 때문에, 다른 프로세스의 영향을 받지 않는다. 각각의 프로세스는 자신만의 주소 공간, 데이터 스택, 힙 등을 가지고 있다. 반면, 스레드는 하나의 프로세스 안에서 동작하기 때문에, 스레드 간 데이터 공유가 쉽다. 여러 스레드를 사용하는 경우, 프로세스보다 더 적은 자원(메모라 등)을 사용할 수 있다.
3. 안정성
   * 각 프로세스는 독립적으로 실행되기 때문에 안정성이 높다. 하나의 프로세스가 비정상적으로 종료되더라도, 다른 프로세스에는 영향을 끼치지 않는다. 반면, 스레드는 하나의 스레드가 예외를 발생시키면, 전체 프로세스가 영향을 받을 수 있다.
4. 생성 및 종료
   * 프로세스는 운영체제에 의해 생성되고, 동일한 방법으로 종료된다. 반면, 스레드는 프로세스 안에서 생성되고, 각 스레드는 프로세스안에서 별도로 종료된다. 스레드는 프로세스 안에서 동시에 실행될 수 있기 때문에, 스레드간의 관리가 필요하다.

### 스레드(Thread) 와 태스크(Task)

모두 비동기 처리를 위한 실행 단위이만 차이점이있다.

1. 리소스 할당
   * 스레드는 프로세스 내부에서 실행되기 때문에, 프로세스가 가지고 있는 메모리 공간 등의 자원을 공유한다. 반면, 태스크는 스레드와 달리 별도의 메모리 공간을 가지고 있으며, 필요한 만큼만 할당 받아 사용한다.
2. 동작 방식
   * 스레드는 하나의 프로세스 내에서 실행되는 것으로, 다른 스레드와 공유하는 메모리 공간 등 자원을 사용한다. 반면, 태스크는 스레드와 독립적으로 동작하기 때문에, 스레드 간의 자원 공유를 사용하지 않는다.
3. 생성 및 종료
   * 스레드는 프로세스 내에서 생성되며, 해당 프로세스의 실행에 종속적이다. 스레드는 프로세스의 메모리 공간을 공유하고 있기 때문에, 한 스레드가 비정상적으로 종료될 경우 다른 스레드도 영향을 받을 수 있다. 반면, 테스크는 스레드와는 별도의 실행 단위로, 독립적으로 생성되어 동작한다.
4. 실행 흐름 관리
   * 스레드는 운영체제에 의해 스케줄링되며, 실행 흐름을 운영체제가 관리한다. 반면, 태스크는 일반적으로 비동기 처리를 위한 라이브러리에서 제공하며, 개발자가 직접 실행 흐름을 관리한다.
5. 오버헤드
   * 스레드는 실행 중인 프로세스의 메모리 공간을 공유하기 때문에, 스레드 간의 데이터 공유가 쉽고 빠르다. 하지만, 스레드 생성과 제거에 따른 오버헤드가 발생할 수 있다. 반면, 태스크는 스레드와 독립적으로 동작하기 때문에, 스레드 생성 및 제거 오버헤드가 없다.

### 스레드(Thread) 와 코루틴(Coroutine)

스레드와 코루틴은 모두 비동기 처리를 위한 실행 단위이자만 차이가 있다.

1. 동시성
   * 스레드는 운영체제에 의해 스케줄링되며, 여러 스레드가 동시에 실행될 수 있다. 반면, 코루틴은 하나의 스레드 내에서 실행되며, 동시에 여러 코리틴이 실행되는 것은 아니다.
2. 리소스 할당
   * 스레드는 프로세스 내부에서 실행되기 떄문에, 프로세스가 가지고 있는 메모리 공간 등의 자원을 공유한다. 바념ㄴ, 코루틴은 스레드와 마찬가지로 별도의 메모리 공간을 갖고 있지만, 필요한 만큼만 할당 받아 사용한다.
3. 실행 흐름 제어
   * 스레드는 운영체제에 의해 스케줄링되며, 실행 흐름을 운영체제가 관리한다. 반면, 코루틴은 개발자가 직접 실행흐름을 제어한다. 코루틴은 중단되고 다시 시작될 수 있으며, 중단점에서 현재 상태를 저장하고 다음 실행 시점에서 그 상태를 복원할 수 있다.
4. 오버헤드
   * 스레드는 실행 중인 프로세스의 메모리 공간을 공유하기 때문에, 스레드 간의 데이터 공유가 쉽고 빠르다. 하지만, 스레드 생성과 제거에 따른 오버헤드가 발생할 수 있다. 반면, 코루틴은 스레드와 독립적으로 동작하기 때문에, 스레드 생성 및 제거 오버헤드가 없다.
5. 디버깅
   * 스레드는 여러 개의 실행 스레드가 동시에 동작하므로, 디버깅이 어려울 수 있다. 반면, 코루틴은 하나의 스레드 내에서 실행되기 때문에 디버깅이 상대적으로 쉽다.